// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 21 Oct 2024 09:12:13 UTC.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package lib

/*
#cgo linux LDFLAGS: -Wl,--export-dynamic -Wl,--unresolved-symbols=ignore-in-object-files
#cgo darwin LDFLAGS: -Wl,-undefined,dynamic_lookup
#include "cndev.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *CardInfo_t) Ref() *C.cndevCardInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardInfo_tRef(ref unsafe.Pointer) *CardInfo_t {
	return (*CardInfo_t)(ref)
}

// NewCardInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardInfo_t() *CardInfo_t {
	return (*CardInfo_t)(allocCardInfo_tMemory(1))
}

// allocCardInfo_tMemory allocates memory for type C.cndevCardInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardInfo_tValue = unsafe.Sizeof([1]C.cndevCardInfo_t{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardInfo_t) PassRef() *C.cndevCardInfo_t {
	if x == nil {
		x = (*CardInfo_t)(allocCardInfo_tMemory(1))
	}
	return (*C.cndevCardInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *UUID_t) Ref() *C.cndevUUID_t {
	if x == nil {
		return nil
	}
	return (*C.cndevUUID_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *UUID_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewUUID_tRef converts the C object reference into a raw struct reference without wrapping.
func NewUUID_tRef(ref unsafe.Pointer) *UUID_t {
	return (*UUID_t)(ref)
}

// NewUUID_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewUUID_t() *UUID_t {
	return (*UUID_t)(allocUUID_tMemory(1))
}

// allocUUID_tMemory allocates memory for type C.cndevUUID_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUUID_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUUID_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUUID_tValue = unsafe.Sizeof([1]C.cndevUUID_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *UUID_t) PassRef() *C.cndevUUID_t {
	if x == nil {
		x = (*UUID_t)(allocUUID_tMemory(1))
	}
	return (*C.cndevUUID_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MemoryInfo_t) Ref() *C.cndevMemoryInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMemoryInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MemoryInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMemoryInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMemoryInfo_tRef(ref unsafe.Pointer) *MemoryInfo_t {
	return (*MemoryInfo_t)(ref)
}

// NewMemoryInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMemoryInfo_t() *MemoryInfo_t {
	return (*MemoryInfo_t)(allocMemoryInfo_tMemory(1))
}

// allocMemoryInfo_tMemory allocates memory for type C.cndevMemoryInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryInfo_tValue = unsafe.Sizeof([1]C.cndevMemoryInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MemoryInfo_t) PassRef() *C.cndevMemoryInfo_t {
	if x == nil {
		x = (*MemoryInfo_t)(allocMemoryInfo_tMemory(1))
	}
	return (*C.cndevMemoryInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *VersionInfo_t) Ref() *C.cndevVersionInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevVersionInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *VersionInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewVersionInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewVersionInfo_tRef(ref unsafe.Pointer) *VersionInfo_t {
	return (*VersionInfo_t)(ref)
}

// NewVersionInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewVersionInfo_t() *VersionInfo_t {
	return (*VersionInfo_t)(allocVersionInfo_tMemory(1))
}

// allocVersionInfo_tMemory allocates memory for type C.cndevVersionInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVersionInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVersionInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVersionInfo_tValue = unsafe.Sizeof([1]C.cndevVersionInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *VersionInfo_t) PassRef() *C.cndevVersionInfo_t {
	if x == nil {
		x = (*VersionInfo_t)(allocVersionInfo_tMemory(1))
	}
	return (*C.cndevVersionInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ECCInfo_t) Ref() *C.cndevECCInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevECCInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ECCInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewECCInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewECCInfo_tRef(ref unsafe.Pointer) *ECCInfo_t {
	return (*ECCInfo_t)(ref)
}

// NewECCInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewECCInfo_t() *ECCInfo_t {
	return (*ECCInfo_t)(allocECCInfo_tMemory(1))
}

// allocECCInfo_tMemory allocates memory for type C.cndevECCInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocECCInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfECCInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfECCInfo_tValue = unsafe.Sizeof([1]C.cndevECCInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ECCInfo_t) PassRef() *C.cndevECCInfo_t {
	if x == nil {
		x = (*ECCInfo_t)(allocECCInfo_tMemory(1))
	}
	return (*C.cndevECCInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PowerInfo_t) Ref() *C.cndevPowerInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevPowerInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PowerInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPowerInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewPowerInfo_tRef(ref unsafe.Pointer) *PowerInfo_t {
	return (*PowerInfo_t)(ref)
}

// NewPowerInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPowerInfo_t() *PowerInfo_t {
	return (*PowerInfo_t)(allocPowerInfo_tMemory(1))
}

// allocPowerInfo_tMemory allocates memory for type C.cndevPowerInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPowerInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPowerInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPowerInfo_tValue = unsafe.Sizeof([1]C.cndevPowerInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PowerInfo_t) PassRef() *C.cndevPowerInfo_t {
	if x == nil {
		x = (*PowerInfo_t)(allocPowerInfo_tMemory(1))
	}
	return (*C.cndevPowerInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TemperatureInfo_t) Ref() *C.cndevTemperatureInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevTemperatureInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TemperatureInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTemperatureInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewTemperatureInfo_tRef(ref unsafe.Pointer) *TemperatureInfo_t {
	return (*TemperatureInfo_t)(ref)
}

// NewTemperatureInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTemperatureInfo_t() *TemperatureInfo_t {
	return (*TemperatureInfo_t)(allocTemperatureInfo_tMemory(1))
}

// allocTemperatureInfo_tMemory allocates memory for type C.cndevTemperatureInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTemperatureInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTemperatureInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTemperatureInfo_tValue = unsafe.Sizeof([1]C.cndevTemperatureInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TemperatureInfo_t) PassRef() *C.cndevTemperatureInfo_t {
	if x == nil {
		x = (*TemperatureInfo_t)(allocTemperatureInfo_tMemory(1))
	}
	return (*C.cndevTemperatureInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FanSpeedInfo_t) Ref() *C.cndevFanSpeedInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevFanSpeedInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FanSpeedInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFanSpeedInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewFanSpeedInfo_tRef(ref unsafe.Pointer) *FanSpeedInfo_t {
	return (*FanSpeedInfo_t)(ref)
}

// NewFanSpeedInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFanSpeedInfo_t() *FanSpeedInfo_t {
	return (*FanSpeedInfo_t)(allocFanSpeedInfo_tMemory(1))
}

// allocFanSpeedInfo_tMemory allocates memory for type C.cndevFanSpeedInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFanSpeedInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFanSpeedInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFanSpeedInfo_tValue = unsafe.Sizeof([1]C.cndevFanSpeedInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FanSpeedInfo_t) PassRef() *C.cndevFanSpeedInfo_t {
	if x == nil {
		x = (*FanSpeedInfo_t)(allocFanSpeedInfo_tMemory(1))
	}
	return (*C.cndevFanSpeedInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LLCInfo_t) Ref() *C.cndevLLCInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevLLCInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LLCInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLLCInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewLLCInfo_tRef(ref unsafe.Pointer) *LLCInfo_t {
	return (*LLCInfo_t)(ref)
}

// NewLLCInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLLCInfo_t() *LLCInfo_t {
	return (*LLCInfo_t)(allocLLCInfo_tMemory(1))
}

// allocLLCInfo_tMemory allocates memory for type C.cndevLLCInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLLCInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLLCInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLLCInfo_tValue = unsafe.Sizeof([1]C.cndevLLCInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LLCInfo_t) PassRef() *C.cndevLLCInfo_t {
	if x == nil {
		x = (*LLCInfo_t)(allocLLCInfo_tMemory(1))
	}
	return (*C.cndevLLCInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *UtilizationInfo_t) Ref() *C.cndevUtilizationInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevUtilizationInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *UtilizationInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewUtilizationInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewUtilizationInfo_tRef(ref unsafe.Pointer) *UtilizationInfo_t {
	return (*UtilizationInfo_t)(ref)
}

// NewUtilizationInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewUtilizationInfo_t() *UtilizationInfo_t {
	return (*UtilizationInfo_t)(allocUtilizationInfo_tMemory(1))
}

// allocUtilizationInfo_tMemory allocates memory for type C.cndevUtilizationInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUtilizationInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUtilizationInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUtilizationInfo_tValue = unsafe.Sizeof([1]C.cndevUtilizationInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *UtilizationInfo_t) PassRef() *C.cndevUtilizationInfo_t {
	if x == nil {
		x = (*UtilizationInfo_t)(allocUtilizationInfo_tMemory(1))
	}
	return (*C.cndevUtilizationInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FrequencyInfo_t) Ref() *C.cndevFrequencyInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevFrequencyInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FrequencyInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFrequencyInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewFrequencyInfo_tRef(ref unsafe.Pointer) *FrequencyInfo_t {
	return (*FrequencyInfo_t)(ref)
}

// NewFrequencyInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFrequencyInfo_t() *FrequencyInfo_t {
	return (*FrequencyInfo_t)(allocFrequencyInfo_tMemory(1))
}

// allocFrequencyInfo_tMemory allocates memory for type C.cndevFrequencyInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFrequencyInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFrequencyInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFrequencyInfo_tValue = unsafe.Sizeof([1]C.cndevFrequencyInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FrequencyInfo_t) PassRef() *C.cndevFrequencyInfo_t {
	if x == nil {
		x = (*FrequencyInfo_t)(allocFrequencyInfo_tMemory(1))
	}
	return (*C.cndevFrequencyInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ProcessInfo_t) Ref() *C.cndevProcessInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevProcessInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ProcessInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewProcessInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewProcessInfo_tRef(ref unsafe.Pointer) *ProcessInfo_t {
	return (*ProcessInfo_t)(ref)
}

// NewProcessInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewProcessInfo_t() *ProcessInfo_t {
	return (*ProcessInfo_t)(allocProcessInfo_tMemory(1))
}

// allocProcessInfo_tMemory allocates memory for type C.cndevProcessInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProcessInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProcessInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfProcessInfo_tValue = unsafe.Sizeof([1]C.cndevProcessInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ProcessInfo_t) PassRef() *C.cndevProcessInfo_t {
	if x == nil {
		x = (*ProcessInfo_t)(allocProcessInfo_tMemory(1))
	}
	return (*C.cndevProcessInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LibVersionInfo_t) Ref() *C.cndevLibVersionInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevLibVersionInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LibVersionInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLibVersionInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewLibVersionInfo_tRef(ref unsafe.Pointer) *LibVersionInfo_t {
	return (*LibVersionInfo_t)(ref)
}

// NewLibVersionInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLibVersionInfo_t() *LibVersionInfo_t {
	return (*LibVersionInfo_t)(allocLibVersionInfo_tMemory(1))
}

// allocLibVersionInfo_tMemory allocates memory for type C.cndevLibVersionInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLibVersionInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLibVersionInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLibVersionInfo_tValue = unsafe.Sizeof([1]C.cndevLibVersionInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LibVersionInfo_t) PassRef() *C.cndevLibVersionInfo_t {
	if x == nil {
		x = (*LibVersionInfo_t)(allocLibVersionInfo_tMemory(1))
	}
	return (*C.cndevLibVersionInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CardCoreCount_t) Ref() *C.cndevCardCoreCount_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardCoreCount_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardCoreCount_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardCoreCount_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardCoreCount_tRef(ref unsafe.Pointer) *CardCoreCount_t {
	return (*CardCoreCount_t)(ref)
}

// NewCardCoreCount_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardCoreCount_t() *CardCoreCount_t {
	return (*CardCoreCount_t)(allocCardCoreCount_tMemory(1))
}

// allocCardCoreCount_tMemory allocates memory for type C.cndevCardCoreCount_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardCoreCount_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardCoreCount_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardCoreCount_tValue = unsafe.Sizeof([1]C.cndevCardCoreCount_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardCoreCount_t) PassRef() *C.cndevCardCoreCount_t {
	if x == nil {
		x = (*CardCoreCount_t)(allocCardCoreCount_tMemory(1))
	}
	return (*C.cndevCardCoreCount_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CardClusterCount_t) Ref() *C.cndevCardClusterCount_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardClusterCount_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardClusterCount_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardClusterCount_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardClusterCount_tRef(ref unsafe.Pointer) *CardClusterCount_t {
	return (*CardClusterCount_t)(ref)
}

// NewCardClusterCount_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardClusterCount_t() *CardClusterCount_t {
	return (*CardClusterCount_t)(allocCardClusterCount_tMemory(1))
}

// allocCardClusterCount_tMemory allocates memory for type C.cndevCardClusterCount_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardClusterCount_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardClusterCount_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardClusterCount_tValue = unsafe.Sizeof([1]C.cndevCardClusterCount_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardClusterCount_t) PassRef() *C.cndevCardClusterCount_t {
	if x == nil {
		x = (*CardClusterCount_t)(allocCardClusterCount_tMemory(1))
	}
	return (*C.cndevCardClusterCount_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CardName_t) Ref() *C.cndevCardName_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardName_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardName_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardName_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardName_tRef(ref unsafe.Pointer) *CardName_t {
	return (*CardName_t)(ref)
}

// NewCardName_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardName_t() *CardName_t {
	return (*CardName_t)(allocCardName_tMemory(1))
}

// allocCardName_tMemory allocates memory for type C.cndevCardName_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardName_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardName_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardName_tValue = unsafe.Sizeof([1]C.cndevCardName_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardName_t) PassRef() *C.cndevCardName_t {
	if x == nil {
		x = (*CardName_t)(allocCardName_tMemory(1))
	}
	return (*C.cndevCardName_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CodecCount_t) Ref() *C.cndevCodecCount_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCodecCount_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CodecCount_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCodecCount_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCodecCount_tRef(ref unsafe.Pointer) *CodecCount_t {
	return (*CodecCount_t)(ref)
}

// NewCodecCount_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCodecCount_t() *CodecCount_t {
	return (*CodecCount_t)(allocCodecCount_tMemory(1))
}

// allocCodecCount_tMemory allocates memory for type C.cndevCodecCount_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecCount_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecCount_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCodecCount_tValue = unsafe.Sizeof([1]C.cndevCodecCount_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CodecCount_t) PassRef() *C.cndevCodecCount_t {
	if x == nil {
		x = (*CodecCount_t)(allocCodecCount_tMemory(1))
	}
	return (*C.cndevCodecCount_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CodecUtilization_t) Ref() *C.cndevCodecUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCodecUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CodecUtilization_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCodecUtilization_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCodecUtilization_tRef(ref unsafe.Pointer) *CodecUtilization_t {
	return (*CodecUtilization_t)(ref)
}

// NewCodecUtilization_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCodecUtilization_t() *CodecUtilization_t {
	return (*CodecUtilization_t)(allocCodecUtilization_tMemory(1))
}

// allocCodecUtilization_tMemory allocates memory for type C.cndevCodecUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecUtilization_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecUtilization_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCodecUtilization_tValue = unsafe.Sizeof([1]C.cndevCodecUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CodecUtilization_t) PassRef() *C.cndevCodecUtilization_t {
	if x == nil {
		x = (*CodecUtilization_t)(allocCodecUtilization_tMemory(1))
	}
	return (*C.cndevCodecUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CardSN_t) Ref() *C.cndevCardSN_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardSN_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardSN_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardSN_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardSN_tRef(ref unsafe.Pointer) *CardSN_t {
	return (*CardSN_t)(ref)
}

// NewCardSN_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardSN_t() *CardSN_t {
	return (*CardSN_t)(allocCardSN_tMemory(1))
}

// allocCardSN_tMemory allocates memory for type C.cndevCardSN_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardSN_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardSN_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardSN_tValue = unsafe.Sizeof([1]C.cndevCardSN_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardSN_t) PassRef() *C.cndevCardSN_t {
	if x == nil {
		x = (*CardSN_t)(allocCardSN_tMemory(1))
	}
	return (*C.cndevCardSN_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PCIeInfo_t) Ref() *C.cndevPCIeInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevPCIeInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PCIeInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPCIeInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewPCIeInfo_tRef(ref unsafe.Pointer) *PCIeInfo_t {
	return (*PCIeInfo_t)(ref)
}

// NewPCIeInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPCIeInfo_t() *PCIeInfo_t {
	return (*PCIeInfo_t)(allocPCIeInfo_tMemory(1))
}

// allocPCIeInfo_tMemory allocates memory for type C.cndevPCIeInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCIeInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCIeInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCIeInfo_tValue = unsafe.Sizeof([1]C.cndevPCIeInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PCIeInfo_t) PassRef() *C.cndevPCIeInfo_t {
	if x == nil {
		x = (*PCIeInfo_t)(allocPCIeInfo_tMemory(1))
	}
	return (*C.cndevPCIeInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PCIethroughput_t) Ref() *C.cndevPCIethroughput_t {
	if x == nil {
		return nil
	}
	return (*C.cndevPCIethroughput_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PCIethroughput_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPCIethroughput_tRef converts the C object reference into a raw struct reference without wrapping.
func NewPCIethroughput_tRef(ref unsafe.Pointer) *PCIethroughput_t {
	return (*PCIethroughput_t)(ref)
}

// NewPCIethroughput_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPCIethroughput_t() *PCIethroughput_t {
	return (*PCIethroughput_t)(allocPCIethroughput_tMemory(1))
}

// allocPCIethroughput_tMemory allocates memory for type C.cndevPCIethroughput_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCIethroughput_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCIethroughput_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCIethroughput_tValue = unsafe.Sizeof([1]C.cndevPCIethroughput_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PCIethroughput_t) PassRef() *C.cndevPCIethroughput_t {
	if x == nil {
		x = (*PCIethroughput_t)(allocPCIethroughput_tMemory(1))
	}
	return (*C.cndevPCIethroughput_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Affinity_t) Ref() *C.cndevAffinity_t {
	if x == nil {
		return nil
	}
	return (*C.cndevAffinity_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Affinity_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAffinity_tRef converts the C object reference into a raw struct reference without wrapping.
func NewAffinity_tRef(ref unsafe.Pointer) *Affinity_t {
	return (*Affinity_t)(ref)
}

// NewAffinity_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAffinity_t() *Affinity_t {
	return (*Affinity_t)(allocAffinity_tMemory(1))
}

// allocAffinity_tMemory allocates memory for type C.cndevAffinity_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAffinity_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAffinity_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAffinity_tValue = unsafe.Sizeof([1]C.cndevAffinity_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Affinity_t) PassRef() *C.cndevAffinity_t {
	if x == nil {
		x = (*Affinity_t)(allocAffinity_tMemory(1))
	}
	return (*C.cndevAffinity_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TopologyRelationship_t) Ref() *C.cndevTopologyRelationship_t {
	if x == nil {
		return nil
	}
	return (*C.cndevTopologyRelationship_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TopologyRelationship_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTopologyRelationship_tRef converts the C object reference into a raw struct reference without wrapping.
func NewTopologyRelationship_tRef(ref unsafe.Pointer) *TopologyRelationship_t {
	return (*TopologyRelationship_t)(ref)
}

// NewTopologyRelationship_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTopologyRelationship_t() *TopologyRelationship_t {
	return (*TopologyRelationship_t)(allocTopologyRelationship_tMemory(1))
}

// allocTopologyRelationship_tMemory allocates memory for type C.cndevTopologyRelationship_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTopologyRelationship_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTopologyRelationship_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTopologyRelationship_tValue = unsafe.Sizeof([1]C.cndevTopologyRelationship_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TopologyRelationship_t) PassRef() *C.cndevTopologyRelationship_t {
	if x == nil {
		x = (*TopologyRelationship_t)(allocTopologyRelationship_tMemory(1))
	}
	return (*C.cndevTopologyRelationship_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CurrentPCIInfo_t) Ref() *C.cndevCurrentPCIInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCurrentPCIInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CurrentPCIInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCurrentPCIInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCurrentPCIInfo_tRef(ref unsafe.Pointer) *CurrentPCIInfo_t {
	return (*CurrentPCIInfo_t)(ref)
}

// NewCurrentPCIInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCurrentPCIInfo_t() *CurrentPCIInfo_t {
	return (*CurrentPCIInfo_t)(allocCurrentPCIInfo_tMemory(1))
}

// allocCurrentPCIInfo_tMemory allocates memory for type C.cndevCurrentPCIInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCurrentPCIInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCurrentPCIInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCurrentPCIInfo_tValue = unsafe.Sizeof([1]C.cndevCurrentPCIInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CurrentPCIInfo_t) PassRef() *C.cndevCurrentPCIInfo_t {
	if x == nil {
		x = (*CurrentPCIInfo_t)(allocCurrentPCIInfo_tMemory(1))
	}
	return (*C.cndevCurrentPCIInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TopologyNodeCapInfo_t) Ref() *C.cndevTopologyNodeCapInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevTopologyNodeCapInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TopologyNodeCapInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTopologyNodeCapInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewTopologyNodeCapInfo_tRef(ref unsafe.Pointer) *TopologyNodeCapInfo_t {
	return (*TopologyNodeCapInfo_t)(ref)
}

// NewTopologyNodeCapInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTopologyNodeCapInfo_t() *TopologyNodeCapInfo_t {
	return (*TopologyNodeCapInfo_t)(allocTopologyNodeCapInfo_tMemory(1))
}

// allocTopologyNodeCapInfo_tMemory allocates memory for type C.cndevTopologyNodeCapInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTopologyNodeCapInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTopologyNodeCapInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTopologyNodeCapInfo_tValue = unsafe.Sizeof([1]C.cndevTopologyNodeCapInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TopologyNodeCapInfo_t) PassRef() *C.cndevTopologyNodeCapInfo_t {
	if x == nil {
		x = (*TopologyNodeCapInfo_t)(allocTopologyNodeCapInfo_tMemory(1))
	}
	return (*C.cndevTopologyNodeCapInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TopologyNode_t) Ref() *C.cndevTopologyNode_t {
	if x == nil {
		return nil
	}
	return (*C.cndevTopologyNode_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TopologyNode_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTopologyNode_tRef converts the C object reference into a raw struct reference without wrapping.
func NewTopologyNode_tRef(ref unsafe.Pointer) *TopologyNode_t {
	return (*TopologyNode_t)(ref)
}

// NewTopologyNode_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTopologyNode_t() *TopologyNode_t {
	return (*TopologyNode_t)(allocTopologyNode_tMemory(1))
}

// allocTopologyNode_tMemory allocates memory for type C.cndevTopologyNode_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTopologyNode_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTopologyNode_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTopologyNode_tValue = unsafe.Sizeof([1]C.cndevTopologyNode_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TopologyNode_t) PassRef() *C.cndevTopologyNode_t {
	if x == nil {
		x = (*TopologyNode_t)(allocTopologyNode_tMemory(1))
	}
	return (*C.cndevTopologyNode_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CapabilityInfo_t) Ref() *C.cndevCapabilityInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCapabilityInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CapabilityInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCapabilityInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCapabilityInfo_tRef(ref unsafe.Pointer) *CapabilityInfo_t {
	return (*CapabilityInfo_t)(ref)
}

// NewCapabilityInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCapabilityInfo_t() *CapabilityInfo_t {
	return (*CapabilityInfo_t)(allocCapabilityInfo_tMemory(1))
}

// allocCapabilityInfo_tMemory allocates memory for type C.cndevCapabilityInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCapabilityInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCapabilityInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCapabilityInfo_tValue = unsafe.Sizeof([1]C.cndevCapabilityInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CapabilityInfo_t) PassRef() *C.cndevCapabilityInfo_t {
	if x == nil {
		x = (*CapabilityInfo_t)(allocCapabilityInfo_tMemory(1))
	}
	return (*C.cndevCapabilityInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CardHealthState_t) Ref() *C.cndevCardHealthState_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardHealthState_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardHealthState_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardHealthState_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardHealthState_tRef(ref unsafe.Pointer) *CardHealthState_t {
	return (*CardHealthState_t)(ref)
}

// NewCardHealthState_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardHealthState_t() *CardHealthState_t {
	return (*CardHealthState_t)(allocCardHealthState_tMemory(1))
}

// allocCardHealthState_tMemory allocates memory for type C.cndevCardHealthState_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardHealthState_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardHealthState_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardHealthState_tValue = unsafe.Sizeof([1]C.cndevCardHealthState_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardHealthState_t) PassRef() *C.cndevCardHealthState_t {
	if x == nil {
		x = (*CardHealthState_t)(allocCardHealthState_tMemory(1))
	}
	return (*C.cndevCardHealthState_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LinkSpeed_t) Ref() *C.cndevLinkSpeed_t {
	if x == nil {
		return nil
	}
	return (*C.cndevLinkSpeed_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LinkSpeed_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLinkSpeed_tRef converts the C object reference into a raw struct reference without wrapping.
func NewLinkSpeed_tRef(ref unsafe.Pointer) *LinkSpeed_t {
	return (*LinkSpeed_t)(ref)
}

// NewLinkSpeed_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLinkSpeed_t() *LinkSpeed_t {
	return (*LinkSpeed_t)(allocLinkSpeed_tMemory(1))
}

// allocLinkSpeed_tMemory allocates memory for type C.cndevLinkSpeed_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLinkSpeed_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLinkSpeed_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLinkSpeed_tValue = unsafe.Sizeof([1]C.cndevLinkSpeed_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LinkSpeed_t) PassRef() *C.cndevLinkSpeed_t {
	if x == nil {
		x = (*LinkSpeed_t)(allocLinkSpeed_tMemory(1))
	}
	return (*C.cndevLinkSpeed_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *VideoCodecUtilization_t) Ref() *C.cndevVideoCodecUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.cndevVideoCodecUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *VideoCodecUtilization_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewVideoCodecUtilization_tRef converts the C object reference into a raw struct reference without wrapping.
func NewVideoCodecUtilization_tRef(ref unsafe.Pointer) *VideoCodecUtilization_t {
	return (*VideoCodecUtilization_t)(ref)
}

// NewVideoCodecUtilization_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewVideoCodecUtilization_t() *VideoCodecUtilization_t {
	return (*VideoCodecUtilization_t)(allocVideoCodecUtilization_tMemory(1))
}

// allocVideoCodecUtilization_tMemory allocates memory for type C.cndevVideoCodecUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoCodecUtilization_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoCodecUtilization_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoCodecUtilization_tValue = unsafe.Sizeof([1]C.cndevVideoCodecUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *VideoCodecUtilization_t) PassRef() *C.cndevVideoCodecUtilization_t {
	if x == nil {
		x = (*VideoCodecUtilization_t)(allocVideoCodecUtilization_tMemory(1))
	}
	return (*C.cndevVideoCodecUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ImageCodecUtilization_t) Ref() *C.cndevImageCodecUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.cndevImageCodecUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ImageCodecUtilization_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewImageCodecUtilization_tRef converts the C object reference into a raw struct reference without wrapping.
func NewImageCodecUtilization_tRef(ref unsafe.Pointer) *ImageCodecUtilization_t {
	return (*ImageCodecUtilization_t)(ref)
}

// NewImageCodecUtilization_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewImageCodecUtilization_t() *ImageCodecUtilization_t {
	return (*ImageCodecUtilization_t)(allocImageCodecUtilization_tMemory(1))
}

// allocImageCodecUtilization_tMemory allocates memory for type C.cndevImageCodecUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCodecUtilization_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCodecUtilization_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCodecUtilization_tValue = unsafe.Sizeof([1]C.cndevImageCodecUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ImageCodecUtilization_t) PassRef() *C.cndevImageCodecUtilization_t {
	if x == nil {
		x = (*ImageCodecUtilization_t)(allocImageCodecUtilization_tMemory(1))
	}
	return (*C.cndevImageCodecUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FastAlloc_t) Ref() *C.cndevFastAlloc_t {
	if x == nil {
		return nil
	}
	return (*C.cndevFastAlloc_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FastAlloc_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFastAlloc_tRef converts the C object reference into a raw struct reference without wrapping.
func NewFastAlloc_tRef(ref unsafe.Pointer) *FastAlloc_t {
	return (*FastAlloc_t)(ref)
}

// NewFastAlloc_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFastAlloc_t() *FastAlloc_t {
	return (*FastAlloc_t)(allocFastAlloc_tMemory(1))
}

// allocFastAlloc_tMemory allocates memory for type C.cndevFastAlloc_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFastAlloc_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFastAlloc_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFastAlloc_tValue = unsafe.Sizeof([1]C.cndevFastAlloc_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FastAlloc_t) PassRef() *C.cndevFastAlloc_t {
	if x == nil {
		x = (*FastAlloc_t)(allocFastAlloc_tMemory(1))
	}
	return (*C.cndevFastAlloc_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *NUMANodeId_t) Ref() *C.cndevNUMANodeId_t {
	if x == nil {
		return nil
	}
	return (*C.cndevNUMANodeId_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *NUMANodeId_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNUMANodeId_tRef converts the C object reference into a raw struct reference without wrapping.
func NewNUMANodeId_tRef(ref unsafe.Pointer) *NUMANodeId_t {
	return (*NUMANodeId_t)(ref)
}

// NewNUMANodeId_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNUMANodeId_t() *NUMANodeId_t {
	return (*NUMANodeId_t)(allocNUMANodeId_tMemory(1))
}

// allocNUMANodeId_tMemory allocates memory for type C.cndevNUMANodeId_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNUMANodeId_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNUMANodeId_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfNUMANodeId_tValue = unsafe.Sizeof([1]C.cndevNUMANodeId_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *NUMANodeId_t) PassRef() *C.cndevNUMANodeId_t {
	if x == nil {
		x = (*NUMANodeId_t)(allocNUMANodeId_tMemory(1))
	}
	return (*C.cndevNUMANodeId_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ScalerUtilization_t) Ref() *C.cndevScalerUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.cndevScalerUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ScalerUtilization_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewScalerUtilization_tRef converts the C object reference into a raw struct reference without wrapping.
func NewScalerUtilization_tRef(ref unsafe.Pointer) *ScalerUtilization_t {
	return (*ScalerUtilization_t)(ref)
}

// NewScalerUtilization_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewScalerUtilization_t() *ScalerUtilization_t {
	return (*ScalerUtilization_t)(allocScalerUtilization_tMemory(1))
}

// allocScalerUtilization_tMemory allocates memory for type C.cndevScalerUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocScalerUtilization_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfScalerUtilization_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfScalerUtilization_tValue = unsafe.Sizeof([1]C.cndevScalerUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ScalerUtilization_t) PassRef() *C.cndevScalerUtilization_t {
	if x == nil {
		x = (*ScalerUtilization_t)(allocScalerUtilization_tMemory(1))
	}
	return (*C.cndevScalerUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CodecTurbo_t) Ref() *C.cndevCodecTurbo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCodecTurbo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CodecTurbo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCodecTurbo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCodecTurbo_tRef(ref unsafe.Pointer) *CodecTurbo_t {
	return (*CodecTurbo_t)(ref)
}

// NewCodecTurbo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCodecTurbo_t() *CodecTurbo_t {
	return (*CodecTurbo_t)(allocCodecTurbo_tMemory(1))
}

// allocCodecTurbo_tMemory allocates memory for type C.cndevCodecTurbo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecTurbo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecTurbo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCodecTurbo_tValue = unsafe.Sizeof([1]C.cndevCodecTurbo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CodecTurbo_t) PassRef() *C.cndevCodecTurbo_t {
	if x == nil {
		x = (*CodecTurbo_t)(allocCodecTurbo_tMemory(1))
	}
	return (*C.cndevCodecTurbo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CardMemoryDieCount_t) Ref() *C.cndevCardMemoryDieCount_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardMemoryDieCount_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardMemoryDieCount_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardMemoryDieCount_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardMemoryDieCount_tRef(ref unsafe.Pointer) *CardMemoryDieCount_t {
	return (*CardMemoryDieCount_t)(ref)
}

// NewCardMemoryDieCount_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardMemoryDieCount_t() *CardMemoryDieCount_t {
	return (*CardMemoryDieCount_t)(allocCardMemoryDieCount_tMemory(1))
}

// allocCardMemoryDieCount_tMemory allocates memory for type C.cndevCardMemoryDieCount_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardMemoryDieCount_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardMemoryDieCount_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardMemoryDieCount_tValue = unsafe.Sizeof([1]C.cndevCardMemoryDieCount_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardMemoryDieCount_t) PassRef() *C.cndevCardMemoryDieCount_t {
	if x == nil {
		x = (*CardMemoryDieCount_t)(allocCardMemoryDieCount_tMemory(1))
	}
	return (*C.cndevCardMemoryDieCount_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *QsfpddStatus_t) Ref() *C.cndevQsfpddStatus_t {
	if x == nil {
		return nil
	}
	return (*C.cndevQsfpddStatus_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *QsfpddStatus_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewQsfpddStatus_tRef converts the C object reference into a raw struct reference without wrapping.
func NewQsfpddStatus_tRef(ref unsafe.Pointer) *QsfpddStatus_t {
	return (*QsfpddStatus_t)(ref)
}

// NewQsfpddStatus_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewQsfpddStatus_t() *QsfpddStatus_t {
	return (*QsfpddStatus_t)(allocQsfpddStatus_tMemory(1))
}

// allocQsfpddStatus_tMemory allocates memory for type C.cndevQsfpddStatus_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQsfpddStatus_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQsfpddStatus_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQsfpddStatus_tValue = unsafe.Sizeof([1]C.cndevQsfpddStatus_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *QsfpddStatus_t) PassRef() *C.cndevQsfpddStatus_t {
	if x == nil {
		x = (*QsfpddStatus_t)(allocQsfpddStatus_tMemory(1))
	}
	return (*C.cndevQsfpddStatus_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkVersion_t) Ref() *C.cndevMLULinkVersion_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkVersion_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkVersion_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkVersion_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkVersion_tRef(ref unsafe.Pointer) *MLULinkVersion_t {
	return (*MLULinkVersion_t)(ref)
}

// NewMLULinkVersion_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkVersion_t() *MLULinkVersion_t {
	return (*MLULinkVersion_t)(allocMLULinkVersion_tMemory(1))
}

// allocMLULinkVersion_tMemory allocates memory for type C.cndevMLULinkVersion_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkVersion_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkVersion_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkVersion_tValue = unsafe.Sizeof([1]C.cndevMLULinkVersion_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkVersion_t) PassRef() *C.cndevMLULinkVersion_t {
	if x == nil {
		x = (*MLULinkVersion_t)(allocMLULinkVersion_tMemory(1))
	}
	return (*C.cndevMLULinkVersion_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkStatus_t) Ref() *C.cndevMLULinkStatus_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkStatus_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkStatus_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkStatus_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkStatus_tRef(ref unsafe.Pointer) *MLULinkStatus_t {
	return (*MLULinkStatus_t)(ref)
}

// NewMLULinkStatus_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkStatus_t() *MLULinkStatus_t {
	return (*MLULinkStatus_t)(allocMLULinkStatus_tMemory(1))
}

// allocMLULinkStatus_tMemory allocates memory for type C.cndevMLULinkStatus_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkStatus_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkStatus_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkStatus_tValue = unsafe.Sizeof([1]C.cndevMLULinkStatus_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkStatus_t) PassRef() *C.cndevMLULinkStatus_t {
	if x == nil {
		x = (*MLULinkStatus_t)(allocMLULinkStatus_tMemory(1))
	}
	return (*C.cndevMLULinkStatus_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkSpeed_t) Ref() *C.cndevMLULinkSpeed_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkSpeed_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkSpeed_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkSpeed_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkSpeed_tRef(ref unsafe.Pointer) *MLULinkSpeed_t {
	return (*MLULinkSpeed_t)(ref)
}

// NewMLULinkSpeed_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkSpeed_t() *MLULinkSpeed_t {
	return (*MLULinkSpeed_t)(allocMLULinkSpeed_tMemory(1))
}

// allocMLULinkSpeed_tMemory allocates memory for type C.cndevMLULinkSpeed_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkSpeed_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkSpeed_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkSpeed_tValue = unsafe.Sizeof([1]C.cndevMLULinkSpeed_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkSpeed_t) PassRef() *C.cndevMLULinkSpeed_t {
	if x == nil {
		x = (*MLULinkSpeed_t)(allocMLULinkSpeed_tMemory(1))
	}
	return (*C.cndevMLULinkSpeed_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkCapability_t) Ref() *C.cndevMLULinkCapability_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkCapability_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkCapability_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkCapability_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkCapability_tRef(ref unsafe.Pointer) *MLULinkCapability_t {
	return (*MLULinkCapability_t)(ref)
}

// NewMLULinkCapability_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkCapability_t() *MLULinkCapability_t {
	return (*MLULinkCapability_t)(allocMLULinkCapability_tMemory(1))
}

// allocMLULinkCapability_tMemory allocates memory for type C.cndevMLULinkCapability_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkCapability_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkCapability_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkCapability_tValue = unsafe.Sizeof([1]C.cndevMLULinkCapability_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkCapability_t) PassRef() *C.cndevMLULinkCapability_t {
	if x == nil {
		x = (*MLULinkCapability_t)(allocMLULinkCapability_tMemory(1))
	}
	return (*C.cndevMLULinkCapability_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkCounter_t) Ref() *C.cndevMLULinkCounter_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkCounter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkCounter_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkCounter_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkCounter_tRef(ref unsafe.Pointer) *MLULinkCounter_t {
	return (*MLULinkCounter_t)(ref)
}

// NewMLULinkCounter_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkCounter_t() *MLULinkCounter_t {
	return (*MLULinkCounter_t)(allocMLULinkCounter_tMemory(1))
}

// allocMLULinkCounter_tMemory allocates memory for type C.cndevMLULinkCounter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkCounter_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkCounter_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkCounter_tValue = unsafe.Sizeof([1]C.cndevMLULinkCounter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkCounter_t) PassRef() *C.cndevMLULinkCounter_t {
	if x == nil {
		x = (*MLULinkCounter_t)(allocMLULinkCounter_tMemory(1))
	}
	return (*C.cndevMLULinkCounter_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkSetCounter_t) Ref() *C.cndevMLULinkSetCounter_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkSetCounter_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkSetCounter_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkSetCounter_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkSetCounter_tRef(ref unsafe.Pointer) *MLULinkSetCounter_t {
	return (*MLULinkSetCounter_t)(ref)
}

// NewMLULinkSetCounter_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkSetCounter_t() *MLULinkSetCounter_t {
	return (*MLULinkSetCounter_t)(allocMLULinkSetCounter_tMemory(1))
}

// allocMLULinkSetCounter_tMemory allocates memory for type C.cndevMLULinkSetCounter_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkSetCounter_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkSetCounter_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkSetCounter_tValue = unsafe.Sizeof([1]C.cndevMLULinkSetCounter_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkSetCounter_t) PassRef() *C.cndevMLULinkSetCounter_t {
	if x == nil {
		x = (*MLULinkSetCounter_t)(allocMLULinkSetCounter_tMemory(1))
	}
	return (*C.cndevMLULinkSetCounter_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkRemoteInfo_t) Ref() *C.cndevMLULinkRemoteInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkRemoteInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkRemoteInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkRemoteInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkRemoteInfo_tRef(ref unsafe.Pointer) *MLULinkRemoteInfo_t {
	return (*MLULinkRemoteInfo_t)(ref)
}

// NewMLULinkRemoteInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkRemoteInfo_t() *MLULinkRemoteInfo_t {
	return (*MLULinkRemoteInfo_t)(allocMLULinkRemoteInfo_tMemory(1))
}

// allocMLULinkRemoteInfo_tMemory allocates memory for type C.cndevMLULinkRemoteInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkRemoteInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkRemoteInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkRemoteInfo_tValue = unsafe.Sizeof([1]C.cndevMLULinkRemoteInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkRemoteInfo_t) PassRef() *C.cndevMLULinkRemoteInfo_t {
	if x == nil {
		x = (*MLULinkRemoteInfo_t)(allocMLULinkRemoteInfo_tMemory(1))
	}
	return (*C.cndevMLULinkRemoteInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkDevSN_t) Ref() *C.cndevMLULinkDevSN_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkDevSN_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkDevSN_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkDevSN_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkDevSN_tRef(ref unsafe.Pointer) *MLULinkDevSN_t {
	return (*MLULinkDevSN_t)(ref)
}

// NewMLULinkDevSN_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkDevSN_t() *MLULinkDevSN_t {
	return (*MLULinkDevSN_t)(allocMLULinkDevSN_tMemory(1))
}

// allocMLULinkDevSN_tMemory allocates memory for type C.cndevMLULinkDevSN_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkDevSN_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkDevSN_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkDevSN_tValue = unsafe.Sizeof([1]C.cndevMLULinkDevSN_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkDevSN_t) PassRef() *C.cndevMLULinkDevSN_t {
	if x == nil {
		x = (*MLULinkDevSN_t)(allocMLULinkDevSN_tMemory(1))
	}
	return (*C.cndevMLULinkDevSN_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *NvmeSsdInfo_t) Ref() *C.cndevNvmeSsdInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevNvmeSsdInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *NvmeSsdInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewNvmeSsdInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewNvmeSsdInfo_tRef(ref unsafe.Pointer) *NvmeSsdInfo_t {
	return (*NvmeSsdInfo_t)(ref)
}

// NewNvmeSsdInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewNvmeSsdInfo_t() *NvmeSsdInfo_t {
	return (*NvmeSsdInfo_t)(allocNvmeSsdInfo_tMemory(1))
}

// allocNvmeSsdInfo_tMemory allocates memory for type C.cndevNvmeSsdInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNvmeSsdInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNvmeSsdInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfNvmeSsdInfo_tValue = unsafe.Sizeof([1]C.cndevNvmeSsdInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *NvmeSsdInfo_t) PassRef() *C.cndevNvmeSsdInfo_t {
	if x == nil {
		x = (*NvmeSsdInfo_t)(allocNvmeSsdInfo_tMemory(1))
	}
	return (*C.cndevNvmeSsdInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PsuInfo_t) Ref() *C.cndevPsuInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevPsuInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PsuInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPsuInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewPsuInfo_tRef(ref unsafe.Pointer) *PsuInfo_t {
	return (*PsuInfo_t)(ref)
}

// NewPsuInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPsuInfo_t() *PsuInfo_t {
	return (*PsuInfo_t)(allocPsuInfo_tMemory(1))
}

// allocPsuInfo_tMemory allocates memory for type C.cndevPsuInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPsuInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPsuInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPsuInfo_tValue = unsafe.Sizeof([1]C.cndevPsuInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PsuInfo_t) PassRef() *C.cndevPsuInfo_t {
	if x == nil {
		x = (*PsuInfo_t)(allocPsuInfo_tMemory(1))
	}
	return (*C.cndevPsuInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *IbInfo_t) Ref() *C.cndevIbInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevIbInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *IbInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewIbInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewIbInfo_tRef(ref unsafe.Pointer) *IbInfo_t {
	return (*IbInfo_t)(ref)
}

// NewIbInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewIbInfo_t() *IbInfo_t {
	return (*IbInfo_t)(allocIbInfo_tMemory(1))
}

// allocIbInfo_tMemory allocates memory for type C.cndevIbInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIbInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIbInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIbInfo_tValue = unsafe.Sizeof([1]C.cndevIbInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *IbInfo_t) PassRef() *C.cndevIbInfo_t {
	if x == nil {
		x = (*IbInfo_t)(allocIbInfo_tMemory(1))
	}
	return (*C.cndevIbInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ChassisInfo_t) Ref() *C.cndevChassisInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevChassisInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ChassisInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewChassisInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewChassisInfo_tRef(ref unsafe.Pointer) *ChassisInfo_t {
	return (*ChassisInfo_t)(ref)
}

// NewChassisInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewChassisInfo_t() *ChassisInfo_t {
	return (*ChassisInfo_t)(allocChassisInfo_tMemory(1))
}

// allocChassisInfo_tMemory allocates memory for type C.cndevChassisInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocChassisInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfChassisInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfChassisInfo_tValue = unsafe.Sizeof([1]C.cndevChassisInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ChassisInfo_t) PassRef() *C.cndevChassisInfo_t {
	if x == nil {
		x = (*ChassisInfo_t)(allocChassisInfo_tMemory(1))
	}
	return (*C.cndevChassisInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PCIeFirmwareVersion_t) Ref() *C.cndevPCIeFirmwareVersion_t {
	if x == nil {
		return nil
	}
	return (*C.cndevPCIeFirmwareVersion_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PCIeFirmwareVersion_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPCIeFirmwareVersion_tRef converts the C object reference into a raw struct reference without wrapping.
func NewPCIeFirmwareVersion_tRef(ref unsafe.Pointer) *PCIeFirmwareVersion_t {
	return (*PCIeFirmwareVersion_t)(ref)
}

// NewPCIeFirmwareVersion_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPCIeFirmwareVersion_t() *PCIeFirmwareVersion_t {
	return (*PCIeFirmwareVersion_t)(allocPCIeFirmwareVersion_tMemory(1))
}

// allocPCIeFirmwareVersion_tMemory allocates memory for type C.cndevPCIeFirmwareVersion_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCIeFirmwareVersion_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCIeFirmwareVersion_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCIeFirmwareVersion_tValue = unsafe.Sizeof([1]C.cndevPCIeFirmwareVersion_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PCIeFirmwareVersion_t) PassRef() *C.cndevPCIeFirmwareVersion_t {
	if x == nil {
		x = (*PCIeFirmwareVersion_t)(allocPCIeFirmwareVersion_tMemory(1))
	}
	return (*C.cndevPCIeFirmwareVersion_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceCPUUtilization_t) Ref() *C.cndevDeviceCPUUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.cndevDeviceCPUUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceCPUUtilization_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceCPUUtilization_tRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceCPUUtilization_tRef(ref unsafe.Pointer) *DeviceCPUUtilization_t {
	return (*DeviceCPUUtilization_t)(ref)
}

// NewDeviceCPUUtilization_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceCPUUtilization_t() *DeviceCPUUtilization_t {
	return (*DeviceCPUUtilization_t)(allocDeviceCPUUtilization_tMemory(1))
}

// allocDeviceCPUUtilization_tMemory allocates memory for type C.cndevDeviceCPUUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCPUUtilization_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCPUUtilization_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceCPUUtilization_tValue = unsafe.Sizeof([1]C.cndevDeviceCPUUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceCPUUtilization_t) PassRef() *C.cndevDeviceCPUUtilization_t {
	if x == nil {
		x = (*DeviceCPUUtilization_t)(allocDeviceCPUUtilization_tMemory(1))
	}
	return (*C.cndevDeviceCPUUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceCPUSamplingInterval_t) Ref() *C.cndevDeviceCPUSamplingInterval_t {
	if x == nil {
		return nil
	}
	return (*C.cndevDeviceCPUSamplingInterval_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceCPUSamplingInterval_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceCPUSamplingInterval_tRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceCPUSamplingInterval_tRef(ref unsafe.Pointer) *DeviceCPUSamplingInterval_t {
	return (*DeviceCPUSamplingInterval_t)(ref)
}

// NewDeviceCPUSamplingInterval_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceCPUSamplingInterval_t() *DeviceCPUSamplingInterval_t {
	return (*DeviceCPUSamplingInterval_t)(allocDeviceCPUSamplingInterval_tMemory(1))
}

// allocDeviceCPUSamplingInterval_tMemory allocates memory for type C.cndevDeviceCPUSamplingInterval_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCPUSamplingInterval_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCPUSamplingInterval_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceCPUSamplingInterval_tValue = unsafe.Sizeof([1]C.cndevDeviceCPUSamplingInterval_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceCPUSamplingInterval_t) PassRef() *C.cndevDeviceCPUSamplingInterval_t {
	if x == nil {
		x = (*DeviceCPUSamplingInterval_t)(allocDeviceCPUSamplingInterval_tMemory(1))
	}
	return (*C.cndevDeviceCPUSamplingInterval_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *RetiredPageInfo_t) Ref() *C.cndevRetiredPageInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevRetiredPageInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RetiredPageInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRetiredPageInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewRetiredPageInfo_tRef(ref unsafe.Pointer) *RetiredPageInfo_t {
	return (*RetiredPageInfo_t)(ref)
}

// NewRetiredPageInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRetiredPageInfo_t() *RetiredPageInfo_t {
	return (*RetiredPageInfo_t)(allocRetiredPageInfo_tMemory(1))
}

// allocRetiredPageInfo_tMemory allocates memory for type C.cndevRetiredPageInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRetiredPageInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRetiredPageInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRetiredPageInfo_tValue = unsafe.Sizeof([1]C.cndevRetiredPageInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RetiredPageInfo_t) PassRef() *C.cndevRetiredPageInfo_t {
	if x == nil {
		x = (*RetiredPageInfo_t)(allocRetiredPageInfo_tMemory(1))
	}
	return (*C.cndevRetiredPageInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *RetiredPageStatus_t) Ref() *C.cndevRetiredPageStatus_t {
	if x == nil {
		return nil
	}
	return (*C.cndevRetiredPageStatus_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RetiredPageStatus_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRetiredPageStatus_tRef converts the C object reference into a raw struct reference without wrapping.
func NewRetiredPageStatus_tRef(ref unsafe.Pointer) *RetiredPageStatus_t {
	return (*RetiredPageStatus_t)(ref)
}

// NewRetiredPageStatus_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRetiredPageStatus_t() *RetiredPageStatus_t {
	return (*RetiredPageStatus_t)(allocRetiredPageStatus_tMemory(1))
}

// allocRetiredPageStatus_tMemory allocates memory for type C.cndevRetiredPageStatus_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRetiredPageStatus_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRetiredPageStatus_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRetiredPageStatus_tValue = unsafe.Sizeof([1]C.cndevRetiredPageStatus_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RetiredPageStatus_t) PassRef() *C.cndevRetiredPageStatus_t {
	if x == nil {
		x = (*RetiredPageStatus_t)(allocRetiredPageStatus_tMemory(1))
	}
	return (*C.cndevRetiredPageStatus_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *RemappedRow_t) Ref() *C.cndevRemappedRow_t {
	if x == nil {
		return nil
	}
	return (*C.cndevRemappedRow_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RemappedRow_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRemappedRow_tRef converts the C object reference into a raw struct reference without wrapping.
func NewRemappedRow_tRef(ref unsafe.Pointer) *RemappedRow_t {
	return (*RemappedRow_t)(ref)
}

// NewRemappedRow_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRemappedRow_t() *RemappedRow_t {
	return (*RemappedRow_t)(allocRemappedRow_tMemory(1))
}

// allocRemappedRow_tMemory allocates memory for type C.cndevRemappedRow_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRemappedRow_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRemappedRow_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRemappedRow_tValue = unsafe.Sizeof([1]C.cndevRemappedRow_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RemappedRow_t) PassRef() *C.cndevRemappedRow_t {
	if x == nil {
		x = (*RemappedRow_t)(allocRemappedRow_tMemory(1))
	}
	return (*C.cndevRemappedRow_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *RetiredPageOperation_t) Ref() *C.cndevRetiredPageOperation_t {
	if x == nil {
		return nil
	}
	return (*C.cndevRetiredPageOperation_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RetiredPageOperation_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRetiredPageOperation_tRef converts the C object reference into a raw struct reference without wrapping.
func NewRetiredPageOperation_tRef(ref unsafe.Pointer) *RetiredPageOperation_t {
	return (*RetiredPageOperation_t)(ref)
}

// NewRetiredPageOperation_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRetiredPageOperation_t() *RetiredPageOperation_t {
	return (*RetiredPageOperation_t)(allocRetiredPageOperation_tMemory(1))
}

// allocRetiredPageOperation_tMemory allocates memory for type C.cndevRetiredPageOperation_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRetiredPageOperation_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRetiredPageOperation_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRetiredPageOperation_tValue = unsafe.Sizeof([1]C.cndevRetiredPageOperation_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RetiredPageOperation_t) PassRef() *C.cndevRetiredPageOperation_t {
	if x == nil {
		x = (*RetiredPageOperation_t)(allocRetiredPageOperation_tMemory(1))
	}
	return (*C.cndevRetiredPageOperation_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CardVfState_t) Ref() *C.cndevCardVfState_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCardVfState_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CardVfState_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCardVfState_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCardVfState_tRef(ref unsafe.Pointer) *CardVfState_t {
	return (*CardVfState_t)(ref)
}

// NewCardVfState_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCardVfState_t() *CardVfState_t {
	return (*CardVfState_t)(allocCardVfState_tMemory(1))
}

// allocCardVfState_tMemory allocates memory for type C.cndevCardVfState_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCardVfState_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCardVfState_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCardVfState_tValue = unsafe.Sizeof([1]C.cndevCardVfState_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CardVfState_t) PassRef() *C.cndevCardVfState_t {
	if x == nil {
		x = (*CardVfState_t)(allocCardVfState_tMemory(1))
	}
	return (*C.cndevCardVfState_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkPortMode_t) Ref() *C.cndevMLULinkPortMode_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkPortMode_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkPortMode_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkPortMode_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkPortMode_tRef(ref unsafe.Pointer) *MLULinkPortMode_t {
	return (*MLULinkPortMode_t)(ref)
}

// NewMLULinkPortMode_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkPortMode_t() *MLULinkPortMode_t {
	return (*MLULinkPortMode_t)(allocMLULinkPortMode_tMemory(1))
}

// allocMLULinkPortMode_tMemory allocates memory for type C.cndevMLULinkPortMode_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkPortMode_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkPortMode_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkPortMode_tValue = unsafe.Sizeof([1]C.cndevMLULinkPortMode_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkPortMode_t) PassRef() *C.cndevMLULinkPortMode_t {
	if x == nil {
		x = (*MLULinkPortMode_t)(allocMLULinkPortMode_tMemory(1))
	}
	return (*C.cndevMLULinkPortMode_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkPortRoceCtrl_t) Ref() *C.cndevMLULinkPortRoceCtrl_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkPortRoceCtrl_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkPortRoceCtrl_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkPortRoceCtrl_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkPortRoceCtrl_tRef(ref unsafe.Pointer) *MLULinkPortRoceCtrl_t {
	return (*MLULinkPortRoceCtrl_t)(ref)
}

// NewMLULinkPortRoceCtrl_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkPortRoceCtrl_t() *MLULinkPortRoceCtrl_t {
	return (*MLULinkPortRoceCtrl_t)(allocMLULinkPortRoceCtrl_tMemory(1))
}

// allocMLULinkPortRoceCtrl_tMemory allocates memory for type C.cndevMLULinkPortRoceCtrl_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkPortRoceCtrl_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkPortRoceCtrl_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkPortRoceCtrl_tValue = unsafe.Sizeof([1]C.cndevMLULinkPortRoceCtrl_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkPortRoceCtrl_t) PassRef() *C.cndevMLULinkPortRoceCtrl_t {
	if x == nil {
		x = (*MLULinkPortRoceCtrl_t)(allocMLULinkPortRoceCtrl_tMemory(1))
	}
	return (*C.cndevMLULinkPortRoceCtrl_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TinyCoreUtilization_t) Ref() *C.cndevTinyCoreUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.cndevTinyCoreUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TinyCoreUtilization_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTinyCoreUtilization_tRef converts the C object reference into a raw struct reference without wrapping.
func NewTinyCoreUtilization_tRef(ref unsafe.Pointer) *TinyCoreUtilization_t {
	return (*TinyCoreUtilization_t)(ref)
}

// NewTinyCoreUtilization_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTinyCoreUtilization_t() *TinyCoreUtilization_t {
	return (*TinyCoreUtilization_t)(allocTinyCoreUtilization_tMemory(1))
}

// allocTinyCoreUtilization_tMemory allocates memory for type C.cndevTinyCoreUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTinyCoreUtilization_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTinyCoreUtilization_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTinyCoreUtilization_tValue = unsafe.Sizeof([1]C.cndevTinyCoreUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TinyCoreUtilization_t) PassRef() *C.cndevTinyCoreUtilization_t {
	if x == nil {
		x = (*TinyCoreUtilization_t)(allocTinyCoreUtilization_tMemory(1))
	}
	return (*C.cndevTinyCoreUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ArmOsMemoryInfo_t) Ref() *C.cndevArmOsMemoryInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevArmOsMemoryInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ArmOsMemoryInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewArmOsMemoryInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewArmOsMemoryInfo_tRef(ref unsafe.Pointer) *ArmOsMemoryInfo_t {
	return (*ArmOsMemoryInfo_t)(ref)
}

// NewArmOsMemoryInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewArmOsMemoryInfo_t() *ArmOsMemoryInfo_t {
	return (*ArmOsMemoryInfo_t)(allocArmOsMemoryInfo_tMemory(1))
}

// allocArmOsMemoryInfo_tMemory allocates memory for type C.cndevArmOsMemoryInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArmOsMemoryInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArmOsMemoryInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfArmOsMemoryInfo_tValue = unsafe.Sizeof([1]C.cndevArmOsMemoryInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ArmOsMemoryInfo_t) PassRef() *C.cndevArmOsMemoryInfo_t {
	if x == nil {
		x = (*ArmOsMemoryInfo_t)(allocArmOsMemoryInfo_tMemory(1))
	}
	return (*C.cndevArmOsMemoryInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ChipId_t) Ref() *C.cndevChipId_t {
	if x == nil {
		return nil
	}
	return (*C.cndevChipId_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ChipId_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewChipId_tRef converts the C object reference into a raw struct reference without wrapping.
func NewChipId_tRef(ref unsafe.Pointer) *ChipId_t {
	return (*ChipId_t)(ref)
}

// NewChipId_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewChipId_t() *ChipId_t {
	return (*ChipId_t)(allocChipId_tMemory(1))
}

// allocChipId_tMemory allocates memory for type C.cndevChipId_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocChipId_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfChipId_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfChipId_tValue = unsafe.Sizeof([1]C.cndevChipId_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ChipId_t) PassRef() *C.cndevChipId_t {
	if x == nil {
		x = (*ChipId_t)(allocChipId_tMemory(1))
	}
	return (*C.cndevChipId_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLUFrequencyStatus_t) Ref() *C.cndevMLUFrequencyStatus_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLUFrequencyStatus_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLUFrequencyStatus_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLUFrequencyStatus_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLUFrequencyStatus_tRef(ref unsafe.Pointer) *MLUFrequencyStatus_t {
	return (*MLUFrequencyStatus_t)(ref)
}

// NewMLUFrequencyStatus_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLUFrequencyStatus_t() *MLUFrequencyStatus_t {
	return (*MLUFrequencyStatus_t)(allocMLUFrequencyStatus_tMemory(1))
}

// allocMLUFrequencyStatus_tMemory allocates memory for type C.cndevMLUFrequencyStatus_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLUFrequencyStatus_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLUFrequencyStatus_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLUFrequencyStatus_tValue = unsafe.Sizeof([1]C.cndevMLUFrequencyStatus_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLUFrequencyStatus_t) PassRef() *C.cndevMLUFrequencyStatus_t {
	if x == nil {
		x = (*MLUFrequencyStatus_t)(allocMLUFrequencyStatus_tMemory(1))
	}
	return (*C.cndevMLUFrequencyStatus_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MLULinkPortIP_t) Ref() *C.cndevMLULinkPortIP_t {
	if x == nil {
		return nil
	}
	return (*C.cndevMLULinkPortIP_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MLULinkPortIP_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMLULinkPortIP_tRef converts the C object reference into a raw struct reference without wrapping.
func NewMLULinkPortIP_tRef(ref unsafe.Pointer) *MLULinkPortIP_t {
	return (*MLULinkPortIP_t)(ref)
}

// NewMLULinkPortIP_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMLULinkPortIP_t() *MLULinkPortIP_t {
	return (*MLULinkPortIP_t)(allocMLULinkPortIP_tMemory(1))
}

// allocMLULinkPortIP_tMemory allocates memory for type C.cndevMLULinkPortIP_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMLULinkPortIP_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMLULinkPortIP_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMLULinkPortIP_tValue = unsafe.Sizeof([1]C.cndevMLULinkPortIP_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MLULinkPortIP_t) PassRef() *C.cndevMLULinkPortIP_t {
	if x == nil {
		x = (*MLULinkPortIP_t)(allocMLULinkPortIP_tMemory(1))
	}
	return (*C.cndevMLULinkPortIP_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CRCInfo_t) Ref() *C.cndevCRCInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevCRCInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CRCInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCRCInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewCRCInfo_tRef(ref unsafe.Pointer) *CRCInfo_t {
	return (*CRCInfo_t)(ref)
}

// NewCRCInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCRCInfo_t() *CRCInfo_t {
	return (*CRCInfo_t)(allocCRCInfo_tMemory(1))
}

// allocCRCInfo_tMemory allocates memory for type C.cndevCRCInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCRCInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCRCInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCRCInfo_tValue = unsafe.Sizeof([1]C.cndevCRCInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CRCInfo_t) PassRef() *C.cndevCRCInfo_t {
	if x == nil {
		x = (*CRCInfo_t)(allocCRCInfo_tMemory(1))
	}
	return (*C.cndevCRCInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DDRInfo_t) Ref() *C.cndevDDRInfo_t {
	if x == nil {
		return nil
	}
	return (*C.cndevDDRInfo_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DDRInfo_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDDRInfo_tRef converts the C object reference into a raw struct reference without wrapping.
func NewDDRInfo_tRef(ref unsafe.Pointer) *DDRInfo_t {
	return (*DDRInfo_t)(ref)
}

// NewDDRInfo_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDDRInfo_t() *DDRInfo_t {
	return (*DDRInfo_t)(allocDDRInfo_tMemory(1))
}

// allocDDRInfo_tMemory allocates memory for type C.cndevDDRInfo_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDDRInfo_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDDRInfo_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDDRInfo_tValue = unsafe.Sizeof([1]C.cndevDDRInfo_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DDRInfo_t) PassRef() *C.cndevDDRInfo_t {
	if x == nil {
		x = (*DDRInfo_t)(allocDDRInfo_tMemory(1))
	}
	return (*C.cndevDDRInfo_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *SetIpuFrequency_t) Ref() *C.cndevSetIpuFrequency_t {
	if x == nil {
		return nil
	}
	return (*C.cndevSetIpuFrequency_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *SetIpuFrequency_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSetIpuFrequency_tRef converts the C object reference into a raw struct reference without wrapping.
func NewSetIpuFrequency_tRef(ref unsafe.Pointer) *SetIpuFrequency_t {
	return (*SetIpuFrequency_t)(ref)
}

// NewSetIpuFrequency_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSetIpuFrequency_t() *SetIpuFrequency_t {
	return (*SetIpuFrequency_t)(allocSetIpuFrequency_tMemory(1))
}

// allocSetIpuFrequency_tMemory allocates memory for type C.cndevSetIpuFrequency_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSetIpuFrequency_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSetIpuFrequency_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSetIpuFrequency_tValue = unsafe.Sizeof([1]C.cndevSetIpuFrequency_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *SetIpuFrequency_t) PassRef() *C.cndevSetIpuFrequency_t {
	if x == nil {
		x = (*SetIpuFrequency_t)(allocSetIpuFrequency_tMemory(1))
	}
	return (*C.cndevSetIpuFrequency_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ProcessUtilization_t) Ref() *C.cndevProcessUtilization_t {
	if x == nil {
		return nil
	}
	return (*C.cndevProcessUtilization_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ProcessUtilization_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewProcessUtilization_tRef converts the C object reference into a raw struct reference without wrapping.
func NewProcessUtilization_tRef(ref unsafe.Pointer) *ProcessUtilization_t {
	return (*ProcessUtilization_t)(ref)
}

// NewProcessUtilization_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewProcessUtilization_t() *ProcessUtilization_t {
	return (*ProcessUtilization_t)(allocProcessUtilization_tMemory(1))
}

// allocProcessUtilization_tMemory allocates memory for type C.cndevProcessUtilization_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProcessUtilization_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProcessUtilization_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfProcessUtilization_tValue = unsafe.Sizeof([1]C.cndevProcessUtilization_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ProcessUtilization_t) PassRef() *C.cndevProcessUtilization_t {
	if x == nil {
		x = (*ProcessUtilization_t)(allocProcessUtilization_tMemory(1))
	}
	return (*C.cndevProcessUtilization_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *SupportedIpuFrequency_t) Ref() *C.cndevSupportedIpuFrequency_t {
	if x == nil {
		return nil
	}
	return (*C.cndevSupportedIpuFrequency_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *SupportedIpuFrequency_t) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSupportedIpuFrequency_tRef converts the C object reference into a raw struct reference without wrapping.
func NewSupportedIpuFrequency_tRef(ref unsafe.Pointer) *SupportedIpuFrequency_t {
	return (*SupportedIpuFrequency_t)(ref)
}

// NewSupportedIpuFrequency_t allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSupportedIpuFrequency_t() *SupportedIpuFrequency_t {
	return (*SupportedIpuFrequency_t)(allocSupportedIpuFrequency_tMemory(1))
}

// allocSupportedIpuFrequency_tMemory allocates memory for type C.cndevSupportedIpuFrequency_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSupportedIpuFrequency_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSupportedIpuFrequency_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSupportedIpuFrequency_tValue = unsafe.Sizeof([1]C.cndevSupportedIpuFrequency_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *SupportedIpuFrequency_t) PassRef() *C.cndevSupportedIpuFrequency_t {
	if x == nil {
		x = (*SupportedIpuFrequency_t)(allocSupportedIpuFrequency_tMemory(1))
	}
	return (*C.cndevSupportedIpuFrequency_t)(unsafe.Pointer(x))
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// packSTopologyNode_t reads sliced Go data structure out from plain C format.
func packSTopologyNode_t(v []TopologyNode_t, ptr0 *C.cndevTopologyNode_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTopologyNode_tValue]C.cndevTopologyNode_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTopologyNode_tRef(unsafe.Pointer(&ptr1))
	}
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func (x TRAVERSE_CALLBACK) PassRef() (ref *C.CNDEV_TRAVERSE_CALLBACK, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tRAVERSE_CALLBACK1DDF08DDFunc == nil {
		tRAVERSE_CALLBACK1DDF08DDFunc = x
	}
	return (*C.CNDEV_TRAVERSE_CALLBACK)(C.CNDEV_TRAVERSE_CALLBACK_1ddf08dd), nil
}

func (x TRAVERSE_CALLBACK) PassValue() (ref C.CNDEV_TRAVERSE_CALLBACK, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tRAVERSE_CALLBACK1DDF08DDFunc == nil {
		tRAVERSE_CALLBACK1DDF08DDFunc = x
	}
	return (C.CNDEV_TRAVERSE_CALLBACK)(C.CNDEV_TRAVERSE_CALLBACK_1ddf08dd), nil
}

func NewTRAVERSE_CALLBACKRef(ref unsafe.Pointer) *TRAVERSE_CALLBACK {
	return (*TRAVERSE_CALLBACK)(ref)
}

//export tRAVERSE_CALLBACK1DDF08DD
func tRAVERSE_CALLBACK1DDF08DD(cCurrent *C.cndevTopologyNode_t, cUserdata unsafe.Pointer) C.int {
	if tRAVERSE_CALLBACK1DDF08DDFunc != nil {
		var Current1ddf08dd []TopologyNode_t
		packSTopologyNode_t(Current1ddf08dd, cCurrent)
		Userdata1ddf08dd := (unsafe.Pointer)(unsafe.Pointer(cUserdata))
		ret1ddf08dd := tRAVERSE_CALLBACK1DDF08DDFunc(Current1ddf08dd, Userdata1ddf08dd)
		ret, _ := (C.int)(ret1ddf08dd), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tRAVERSE_CALLBACK1DDF08DDFunc TRAVERSE_CALLBACK

// copyPTopologyNode_tBytes copies the data from Go slice as *C.cndevTopologyNode_t.
func copyPTopologyNode_tBytes(slice *sliceHeader) (*C.cndevTopologyNode_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTopologyNode_tValue) * slice.Len,
		Cap:  int(sizeOfTopologyNode_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.cndevTopologyNode_t)(mem0), allocs
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}
